############################################################################################## RevBayes Validation Test: Occurrence birth-death process## Model: Tree is drawn from a constant-rate fossilized birth-death process with occurrences.### authors: Jérémy Andréoletti (from Walker Pett's FBDP test function #                                   + "Total-evidence dating under the FBD model" tutorial)#############################################################################################seed(0)######################## Reading in the Data ######################### Initial Tree from a previous MCMC#trees = readTreeTrace("output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.trees")#tree_init <- trees.getTree(trees.size())# trace = readTreeTrace("output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.trees")# tree_init <- mccTree(trace, file="output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.tre" )### Read in Datataxa <- readTaxonData("data-cetaceans/Cetacea_genera.csv")sequences_nuc <- readDiscreteCharacterData("data-cetaceans/M4358_nuclear_simplified_newNames_genera_removeOutgroups.nex")sequences_mit <- readDiscreteCharacterData("data-cetaceans/M4376_mt_simplified_newNames_genera_removeOutgroups.nex")morpho <- readDiscreteCharacterData("data-cetaceans/morpho_simplified_newNames_genera_removeOutgroupsUndescribedInvariants.nex")occurrence_ranges <- readMatrix(file="data-cetaceans/Cetacea_occurrences_min_max_age_species_corrected.csv", delimiter=",")# occurrence_ages <- readMatrix(file="data-cetaceans/Cetacea_age_runif_age_species_corrected.csv", delimiter=";")[1]n_taxa <- taxa.size()n_fossils <- 0for (taxon in taxa){  if (taxon.getMaxAge() > 0) { n_fossils += 1 }}n_extant <- n_taxa - n_fossils### Add Missing Taxasequences_nuc.addMissingTaxa( taxa )sequences_mit.addMissingTaxa( taxa )morpho.addMissingTaxa( taxa )### Model Occurrence Age Uncertainty"Model Occurrence Age Uncertainty"for(j in 1:occurrence_ranges.size()) {    min_j = occurrence_ranges[j][1]    max_j = occurrence_ranges[j][2]    occurrence_ages[j] ~ dnUniform(min_j, max_j)    # moves[mvi++] = mvSlide(occurrence_ages[j], delta=0.1,  weight=0.01, tune=TRUE)}n_occ <- occurrence_ages.size()max_age <- ceil(max(occurrence_ages)*100)/100### Set Priors"Set Priors"## Start time of the processstart_time ~ dnUnif(max_age, 60.0)                # Range including all the uncertainties for the Whippomorpha root age from McGowen et al. 2019start_time.setValue((max_age+60)/2)               # Initialise close to the estimated Whippomorpha root age from McGowen et al. 2019## Skyline timelinet1 ~ dnUnif(0,5.333)t1.setValue(3)t_MP <- 5.333              # Miocene_Pliocene boundaryt_TM <- 7.246              # Tortonian-Messinian boundaryt2 ~ dnUnif(7.246,20.43)t2.setValue(15)t_AB <- 20.43              # Aquitian-Burdigalian boundary t_OM <- 23.02              # Oligocene_Miocene (Paleogene-Neogene) boundary t3 ~ dnUnif(23.02,28.1)t3.setValue(25)t_CR <- 28.1               # Chattian-Rupelian boundary t_EO <- 33.9               # Eocene-Oligocene boundary t4 ~ dnUnif(33.9,start_time)t4.setValue(45)timeline := v(t1,t_MP,t_TM,t2,t_AB,t_OM,t3,t_CR,t_EO,t4)## OBDP parameters priors : initialize when possible to speed up convergence# Reparametrization of the speciation and extinction ratesdiv_mean <- ln( ln(n_extant) / start_time )       # Prior mean so that the expected number of species under a Birth-Death process is centred around observed number of cetacean generadiv_sd <- 0.587405                                # Prior standard deviation of 0.587405 creates a lognormal distribution with 95% prior probability spanning exactly one order of magnitudediversification[1] ~ dnLognormal(mean=div_mean,                                 sd=div_sd)       # Diversification represents the rate at which the species diversity increases : diversification = lambda - mudiversification[1].setValue(exp(div_mean))        # Initialize at the meandiversification[2] ~ dnLognormal(mean=ln(diversification[1]), sd=div_sd)diversification[2].setValue(exp(div_mean))diversification[3] := diversification[2]diversification[4] := diversification[2]diversification[5] ~ dnLognormal(mean=ln(diversification[2]), sd=div_sd)diversification[5].setValue(exp(div_mean))diversification[6] := diversification[5]diversification[7] := diversification[5]diversification[8] ~ dnLognormal(mean=ln(diversification[5]), sd=div_sd)diversification[8].setValue(exp(div_mean))diversification[9] := diversification[8]diversification[10] := diversification[8]diversification[11] ~ dnLognormal(mean=ln(diversification[8]), sd=div_sd)diversification[11].setValue(exp(div_mean))mu[1] ~ dnExp(5)                                  # Extinction rate, includes largely the extinction rates estimated by Rabosky (2014)mu[1].setValue(0.05)                              # Initialize according to Rabosky (2014)mu[2] ~ dnExp(1/mu[1])mu[2].setValue(0.05)mu[3] := mu[2]mu[4] := mu[2]mu[5] ~ dnExp(1/mu[2])mu[5].setValue(0.05)mu[6] := mu[5]mu[7] := mu[5]mu[8] ~ dnExp(1/mu[5])mu[8].setValue(0.05)mu[9] := mu[8]mu[10] := mu[8]mu[11] ~ dnExp(1/mu[8])mu[11].setValue(0.05)lambda := diversification + mu                    # Speciation rate# Reparametrization of the fossil sampling ratespsiPlusOmega[1] ~ dnExp(1.0)                      # Global rate of fossil sampling including complete fossils as well as occurrencespsiPlusOmega[1].setValue(0.3)psiPlusOmega[2] := psiPlusOmega[1]bias_Mss ~ dnGamma(2.0,2.0)                       # Messinian : expected lower sampling ratebias_Mss.setValue(0.75)psiPlusOmega[3] := psiPlusOmega[1] * bias_MsspsiPlusOmega[4] := psiPlusOmega[1]psiPlusOmega[5] := psiPlusOmega[1]bias_Aq ~ dnGamma(2.0,2.0)                        # Early Miocene (Aquitalian) : expected lower sampling ratebias_Aq.setValue(0.5)psiPlusOmega[6] := psiPlusOmega[1] * bias_AqpsiPlusOmega[7] := psiPlusOmega[1]psiPlusOmega[8] := psiPlusOmega[1]bias_Rp ~ dnGamma(2.0,2.0)                        # Early Oligocene (Rupelian) : expected much lower sampling ratebias_Rp.setValue(0.1)psiPlusOmega[9] := psiPlusOmega[1] * bias_RppsiPlusOmega[10] := psiPlusOmega[1]psiPlusOmega[11] := psiPlusOmega[1]pm ~ dnUnif(0.0, 1.0)                             # Probability that morphological characters are known for a given fossil : psi = pm * psiPlusOmegapm.setValue(n_fossils / (n_fossils + n_occ))      # Initialize pm at the empirical proportionpsi := pm * psiPlusOmega                          # Complete fossils sampling rateomega := abs(psiPlusOmega - psi)                  # Occurrence sampling raterm <- 0.0                                         # Removal probability at sampling, irrelevant in macroevolution# Sampling at presentrho ~ dnUnif(0.95, 1.0)                           # Sampling probability at present. We have sequences or morphology for all the currently accepted extant cetacean genera, but we allow for some still unknown onesrho.setValue(1.0)# Other parametersN <- 70                                           # Maximum number of hidden lineagescond <- "survival2"                               # Process conditionning : at least 2 lineages survive from the MRCA to the presentuseMt <- FALSE                                    # Choice of the algorithm to compute the likelihoodverbose <- FALSE                                  # Displays more information during the MCMC (ex = optimal N value)# Initialise my move indexmvi = 1# Create some moves for the times or diversification rate shiftmoves[mvi++] = mvSlide(t1, delta=0.5, weight=0.5, tune=TRUE)moves[mvi++] = mvSlide(t2, delta=1.0, weight=0.5, tune=TRUE)moves[mvi++] = mvSlide(t3, delta=0.5, weight=0.5, tune=TRUE)moves[mvi++] = mvSlide(t4, delta=1.0, weight=0.5, tune=TRUE)# Create some moves that change the stochastic variablesmoves[mvi++] = mvScale(diversification[1], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(diversification[2], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(diversification[5], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(diversification[8], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(diversification[11], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(mu[1], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(mu[2], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(mu[5], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(mu[8], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(mu[11], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(psiPlusOmega[1], lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(bias_Mss, lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(bias_Aq, lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvScale(bias_Rp, lambda=1.0, weight=1.0, tune=TRUE)moves[mvi++] = mvSlide(pm, delta=0.01, weight=0.5, tune=TRUE)moves[mvi++] = mvSlide(rho, delta=0.01,  weight=0.5, tune=TRUE)moves[mvi++] = mvSlide(start_time, delta=0.5,  weight=1.0, tune=TRUE)## Occurrence Birth-Death Process Tree Prior"Occurrence Birth-Death Process Tree Prior"obd_dist = dnOBDP(  originAge=start_time,                    timeline=timeline,                    lambda=lambda,                    mu=mu,                     psi=psi,                     omega=omega,                     rho=rho,                     r=rm,                     maxHiddenLin=N,                     condition=cond,                     taxa=taxa,                    occurrence_ages=occurrence_ages,                     useMt=useMt,                    verbose=verbose)                    #initialTree=tree_init)## Clade constraintsArchaeocetes = clade("Georgiacetus_vogtlensis", "Zygorhiza_kochii")Mysteces = clade("Aetiocetus_cotylalveus", "Balaena_mysticetus", "Balaenoptera_physalus", "Mammalodon_colliveri", "Megaptera_novaeangliae", "Eschrichtius_robustus", "Eubalaena_glacialis", "Caperea_marginata", "Eomysticetus_whitmorei", "Micromysticetus_rothauseni", "Diorocetus_hiatus", "Fucaia_goedertorum", "Janjucetus_hunderi", "Parabalaenoptera_baulinensis", "Pelocetus_calvertensis")Odontocetes = clade("Agorophius_pygmaeus", "Albertocetus_meffordorum", "Albireo_whistleri", "Archaeodelphis_patrius", "Cotylocara_macei", "Ashleycetus_planicapitis", "Atocetus_iquensis", "Brachydelphis_mazeasi", "Brujadelphis_ankylorostris", "Delphinus_delphis", "Eodelphinus_kabatensis", "Eurhinodelphis_longirostris", "Hadrodelphis_calvertense", "Hadrodelphis_calvertense", "Lagenodelphis_hosei", "Stenasodelphis_russellae", "Lissodelphis_borealis", "Pithanodelphis_cornutus", "Delphinapterus_leucas", "Delphinodon_dividum", "Auroracetus_bakerae", "Lipotes_vexillifer", "Pliopontos_littoralis", "Pontoporia_blainvillei", "Orcinus_orca", "Orcaella_brevirostris", "Prosqualodon_davidis","Protophocaena_minima", "Australithax_intermedia", "Berardius_bairdii", "Cephalorhynchus_heavisidii", "Echovenator_sandersi", "Feresa_attenuata", "Globicephala_macrorhynchus", "Grampus_griseus", "Haborophocoena_toyoshimai", "Hemisyntrachelus_cortesii", "Hyperoodon_ampullatus", "Indopacetus_pacificus", "Inia_geoffrensis", "Ischyrorhynchus_vanbenedeni", "Kampholophos_serrulus", "Kentriodon_pernix", "Kogia_breviceps", "Lagenorhynchus_albirostris", "Leucopleurus_acutus", "Liolithax_pappus", "Lomacetus_ginsburgi", "Lophocetus_calvertensis", "Macrokentriodon_morani", "Meherrinia_isoni", "Mesoplodon_europaeus", "Mirocetus_riabinini", "Monodon_monoceros", "Neophocaena_phocaenoides", "Ninoziphius_platyrostris", "Notocetus_vanbenedeni", "Odobenocetops_leptodon", "Orycterocetus_crocodilinus", "Otekaikea_marplesi", "Ziphius_cavirostris", "Xenorophus_sloanii", "Squalodon_calvertensis", "Squaloziphius_emlongi", "Simocetus_rayi", "Platanista_gangetica", "Physeter_macrocephalus", "Patriocetus_kazakhstanicus", "Parapontoporia_sternbergi", "Papahu_taitapu", "Peponocephala_electra", "Phocoena_phocoena", "Phocoenoides_dalli", "Piscolithax_longirostris", "Pseudorca_crassidens", "Pterophocaena_nishinoi", "Rudicetus_squalodontoides", "Sotalia_fluviatilis", "Sousa_chinensis", "Stenella_coeruleoalba", "Steno_bredanensis", "Tagicetus_joneti", "Tasmacetus_shepherdi", "Tursiops_truncatus", "Waipatia_maerewhenua", "Xiphiacetus_bossi", "Zarhachis_flagellator")Neocetes = clade(Mysteces, Odontocetes)constraints = v(Archaeocetes, Mysteces, Odontocetes, Neocetes)obd_tree ~ dnConstrainedTopology(obd_dist, constraints=constraints)## Moves to the phylogeny, inspired from April Wright (https://rdrr.io/github/wrightaprilm/Systematics2020/f/vignettes/06_models/index.Rmd)
# Topology moves
moves[mvi++] = mvNarrow(obd_tree, weight=n_taxa/4.0)                     # Nearest-neighbor interchange without changing the node ages
moves[mvi++] = mvFNPR(obd_tree, weight=n_taxa/4.0)                       # Fixed-node-height subtree-prune and regrafting
moves[mvi++] = mvGPR(obd_tree, weight=n_taxa/4.0)                        # Metropolized-Gibbs subtree-prune and regrafting
moves[mvi++] = mvCollapseExpandFossilBranch(obd_tree, start_time, weight=n_fossils/2.0)  # Exchange fossils between tips and sampled ancestors

# Dating moves
moves[mvi++] = mvRootTimeSlideUniform(obd_tree, start_time, weight=2.0)  # Slide the root
moves[mvi++] = mvNNI(obd_tree, weight=n_taxa/4.0)                        # Nearest-neighbor interchange with changing the node ages
moves[mvi++] = mvNodeTimeSlideUniform(obd_tree, weight=n_taxa/2.0)       # Slide the ages of the internal nodes
moves[mvi++] = mvSubtreeScale(obd_tree, weight=n_taxa/4.0)               # Slide the ages of subtrees
### Model Fossil Age Uncertainty"Model Fossil Age Uncertainty"## Fossils with morphologcal charactersfossils = obd_tree.getFossils()for(i in 1:fossils.size()){    t[i] := tmrca(obd_tree, clade(fossils[i]))    a_i = fossils[i].getMinAge()    b_i = fossils[i].getMaxAge()    F[i] ~ dnUniform(t[i] - b_i, t[i] - a_i)    # print("t[i]", t[i], "a_i", a_i, "b_i", b_i)    F[i].clamp( 0 )}moves[mvi++] = mvFossilTimeSlideUniform(obd_tree, start_time, weight=n_fossils/2.0)num_samp_anc := obd_tree.numSampledAncestors();### Model the Evolution of Genetic Sequences"Model the Evolution of Genetic Sequences"## Nuclear sequences# Clock model : uncorrelated exponential relaxedbranch_rates_nuc_mean ~ dnUniform(0.0, 0.01)      # Incorporates largely the rates of nuclear evolution in Allio et al. (2017)branch_rates_nuc_mean.setValue(0.00075)           # Initialize from Dornburg et al. (2011)moves[mvi++] = mvScale(branch_rates_nuc_mean, lambda=0.5, weight=3.0, tune=TRUE)n_branches <- 2 * n_taxa - 2                      # Number of branches in the tree.for(i in 1:n_branches){                           # Define an independent and identically exponentially rate for each branch    branch_rates_nuc[i] ~ dnExp(1/branch_rates_nuc_mean)    branch_rates_nuc[i].setValue(branch_rates_nuc_mean)    moves[mvi++] = mvScale(branch_rates_nuc[i], lambda=0.5, weight=1/10, tune=TRUE)}moves[mvi++] = mvVectorScale(branch_rates_nuc, lambda=0.5, weight=2.0, tune=TRUE)                          # Changes all branch rates simultaneously#moves[mvi++] = mvRateAgeBetaShift(tree=obd_tree, rates=branch_rates_nuc, weight=n_taxa/5.0, tune=TRUE)     # Changes node ages and branch rates jointly, so that the effective branch length remains the same# Substitution model : general time-reversible (GTR) + Γer_hp_nuc <- v(1,1,1,1,1,1)                       # 6 exchangeability rates er_nuc ~ dnDirichlet(er_hp_nuc)                   # Uniform Dirichlet prior distributioner_nuc.setValue(rep(1/6, 6))moves[mvi++] = mvSimplexElementScale(er_nuc, alpha=50.0, weight=2.0, tune=TRUE)sf_hp_nuc <- v(1,1,1,1)                           # 4 stationary frequenciessf_nuc ~ dnDirichlet(sf_hp_nuc)                   # Uniform Dirichlet prior distributionsf_nuc.setValue(rep(0.25, 4))moves[mvi++] = mvSimplexElementScale(sf_nuc, alpha=100.0, weight=4.0, tune=TRUE)Q_seq_nuc := fnGTR(er_nuc,sf_nuc)                 # GTR Q-matrixalpha_seq_nuc ~ dnExponential( 1.0 )              # Shape of the gamma distribution for rates across sitesalpha_seq_nuc.setValue(0.1)moves[mvi++] = mvScale(alpha_seq_nuc, lambda=1.0,  weight=1.0, tune=TRUE)rates_seq_nuc := fnDiscretizeGamma( alpha_seq_nuc, alpha_seq_nuc, 4 )phySeq_nuc ~ dnPhyloCTMC(tree=obd_tree, Q=Q_seq_nuc, siteRates=rates_seq_nuc, branchRates=branch_rates_nuc, type="DNA")phySeq_nuc.clamp(sequences_nuc)## Mitochondrial sequences (expected to evolve faster)# Clock model : uncorrelated exponential relaxedbranch_rates_mit_mean ~ dnUniform(0.0, 0.1)       # Incorporates largely the rates of mitochondrial evolution in Allio et al. (2017)branch_rates_mit_mean.setValue(0.03)              # Initialize from Dornburg et al. (2011)moves[mvi++] = mvScale(branch_rates_mit_mean, lambda=0.5, weight=3.0, tune=TRUE)n_branches <- 2 * n_taxa - 2                      # Number of branches in the tree.for(i in 1:n_branches){                           # Define an independent and identically exponentially rate for each branch    branch_rates_mit[i] ~ dnExp(1/branch_rates_mit_mean)    branch_rates_mit[i].setValue(branch_rates_mit_mean)    moves[mvi++] = mvScale(branch_rates_mit[i], lambda=0.5, weight=1/10, tune=TRUE)}moves[mvi++] = mvVectorScale(branch_rates_mit, lambda=0.5, weight=2.0, tune=TRUE)                          # Changes all branch rates simultaneously#moves[mvi++] = mvRateAgeBetaShift(tree=obd_tree, rates=branch_rates_mit, weight=n_taxa/5.0, tune=TRUE)     # Changes node ages and branch rates jointly, so that the effective branch length remains the same# Substitution model : general time-reversible (GTR) + Γer_hp_mit <- v(1,1,1,1,1,1)                       # 6 exchangeability rates er_mit ~ dnDirichlet(er_hp_mit)                   # Uniform Dirichlet prior distributioner_mit.setValue(rep(1/6, 6))moves[mvi++] = mvSimplexElementScale(er_mit, alpha=50.0, weight=2.0, tune=TRUE)sf_hp_mit <- v(1,1,1,1)                           # 4 stationary frequenciessf_mit ~ dnDirichlet(sf_hp_mit)                   # Uniform Dirichlet prior distributionsf_mit.setValue(rep(0.25, 4))moves[mvi++] = mvSimplexElementScale(sf_mit, alpha=100.0, weight=4.0, tune=TRUE)Q_seq_mit := fnGTR(er_mit,sf_mit)                 # GTR Q-matrixalpha_seq_mit ~ dnExponential( 1.0 )              # Shape of the gamma distribution for rates across sitesalpha_seq_mit.setValue(0.15)moves[mvi++] = mvScale(alpha_seq_mit, lambda=1.0,  weight=1.0, tune=TRUE)rates_seq_mit := fnDiscretizeGamma( alpha_seq_mit, alpha_seq_mit, 4 )phySeq_mit ~ dnPhyloCTMC(tree=obd_tree, Q=Q_seq_mit, siteRates=rates_seq_mit, branchRates=branch_rates_mit, type="DNA")phySeq_mit.clamp(sequences_mit)### Model the Evolution of Morphological Characters"Model the Evolution of Morphological Characters"## From Discrete morphology - Multistate Characters Tutorial (by April M. Wright)alpha_morpho ~ dnExponential( 1.0 )alpha_morpho.setValue(0.5)rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )moves[mvi++] = mvScale(alpha_morpho, lambda=0.5,  weight=10.0, tune=TRUE)clock_morpho ~ dnExponential(1.0)clock_morpho.setValue(0.125)moves[mvi++] = mvScale(clock_morpho, lambda=0.5, weight=10.0, tune=TRUE)n_max_states <- morpho.getStateDescriptions().size()idx = 1morpho_bystate[1] <- morphofor (i in 2:n_max_states) {    morpho_bystate[i] <- morpho                                  # make local tmp copy of data    morpho_bystate[i].setNumStatesPartition(i)                   # only keep character blocks with state space equal to size i    nc = morpho_bystate[i].nchar()                               # get number of characters per character size with i-sized states    if (nc > 0) {                                                # for non-empty character blocks        Q_morpho[idx] <- fnJC(i)                                 # make i-by-i rate matrix        phyMorpho[idx] ~ dnPhyloCTMC(tree=obd_tree,                                     Q=Q_morpho[idx],                                     nSites=nc,                                     siteRates=rates_morpho,                                     branchRates=clock_morpho,                                     type="Standard",                                     coding="variable",                                     treatAmbiguousAsGap=FALSE)  # create model of evolution for the character block        phyMorpho[idx].clamp(morpho_bystate[i])                  # attach the data        idx = idx + 1                                            # increment counter        idx + " states character partition"    }}############## THE Model ################# Define our Model"Define our Model"## We can use any node of our model as a handle, here we chose to use the treemymodel = model(obd_tree)## Set the MCMC monitors (recording traces, printing information during the run)monitors[1] = mnStochasticVariable(filename="output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.out", printgen=1)monitors[2] = mnFile(filename="output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.trees", printgen=1, obd_tree)monitors[3] = mnScreen(printgen=1, start_time, num_samp_anc)# Monitors to print RevGagets input (Macroevolutionary Analysis of Stratigraphic Range Data, Rachel Warnock and Walker Pett)monitors.append( mnFile(filename="output_Cetaceans_genera_constrained/rates_through_time/speciation_rates.log",lambda,printgen=10) )monitors.append( mnFile(filename="output_Cetaceans_genera_constrained/rates_through_time/speciation_times.log",timeline,printgen=10) )monitors.append( mnFile(filename="output_Cetaceans_genera_constrained/rates_through_time/extinction_rates.log",mu,printgen=10) )monitors.append( mnFile(filename="output_Cetaceans_genera_constrained/rates_through_time/extinction_times.log",timeline,printgen=10) )monitors.append( mnFile(filename="output_Cetaceans_genera_constrained/rates_through_time/fossil_sampling_rates.log",psi,printgen=10) )monitors.append( mnFile(filename="output_Cetaceans_genera_constrained/rates_through_time/fossil_sampling_times.log",timeline,printgen=10) )monitors.append( mnFile(filename="output_Cetaceans_genera_constrained/rates_through_time/occurrence_sampling_rates.log",omega,printgen=10) )monitors.append( mnFile(filename="output_Cetaceans_genera_constrained/rates_through_time/occurrence_sampling_times.log",timeline,printgen=10) )# mymcmc = mcmc(mymodel, monitors, moves, moveschedule="single")mymcmc = mcmc(mymodel, monitors, moves)mymcmc.initializeFromCheckpoint(checkpointFile="output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.state")### Run the MCMC"Run the MCMC"mymcmc.run(generations=2000, tuningInterval=10, checkpointInterval=1, checkpointFile="output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.state")# Check the performance of the MCMC/movesmymcmc.operatorSummary()### Read in the Tree Trace and Construct the Maximum Clade Credibility (MCC) Treetrace = readTreeTrace("output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.trees")mccTree(trace, file="output_Cetaceans_genera_constrained/mcmc_OBDP_Cetaceans.tre" )# you may want to quit RevBayes nowq()